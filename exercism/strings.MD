Introduction
------------

AÂ `str`Â in Python is anÂ [immutable sequence](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str)Â ofÂ [Unicode code points](https://stackoverflow.com/questions/27331819/whats-the-difference-between-a-character-a-code-point-a-glyph-and-a-grapheme). These could include letters, diacritical marks, positioning characters, numbers, currency symbols, emoji, punctuation, space and line break characters, and more. Being immutable, aÂ `str`Â object's value in memory doesn't change; methods that appear to modify a string return a new copy or instance of thatÂ `str`Â object.

AÂ `str`Â literal can be declared via singleÂ `'`Â or doubleÂ `"`Â quotes. The escapeÂ `\`Â character is available as needed.

```

>>> single_quoted = 'These allow "double quoting" without "escape" characters.'

>>> double_quoted = "These allow embedded 'single quoting', so you don't have to use an 'escape' character".

>>> escapes = 'If needed, a \'slash\' can be used as an escape character within a string when switching quote styles won\'t work.'

```

Multi-line strings are declared withÂ `'''`Â orÂ `"""`.

```
>>> triple_quoted =  '''Three single quotes or "double quotes" in a row allow for multi-line string literals.
  Line break characters, tabs and other whitespace are fully supported.

  You\'ll most often encounter these as "doc strings" or "doc tests" written just below the first line of a function or class definition.
    They\'re often used with auto documentation âœ tools.
    '''

```

Strings can be concatenated using theÂ `+`Â operator. This method should be used sparingly, as it is not very performant or easily maintained.

```
language = "Ukrainian"
number = "nine"
word = "Ğ´ĞµĞ²'ÑÑ‚ÑŒ"

sentence = word + " " + "means" + " " + number + " in " + language + "."

>>> print(sentence)
...
"Ğ´ĞµĞ²'ÑÑ‚ÑŒ means nine in Ukrainian."

```

If aÂ `list`,Â `tuple`,Â `set`Â or other collection of individual strings needs to be combined into a singleÂ `str`,Â [`<str>.join(<iterable>)`](https://docs.python.org/3/library/stdtypes.html#str.join), is a better option:

```
# str.join() makes a new string from the iterables elements.
>>> chickens = ["hen", "egg", "rooster"]
>>> ' '.join(chickens)
'hen egg rooster'

# Any string can be used as the joining element.
>>> ' :: '.join(chickens)
'hen :: egg :: rooster'

>>> ' ğŸŒ¿ '.join(chickens)
'hen ğŸŒ¿ egg ğŸŒ¿ rooster'

```

Code points within aÂ `str`Â can be referenced byÂ `0-based index`Â number from the left:

```
creative = 'ì°½ì˜ì ì¸'

>>> creative[0]
'ì°½'

>>> creative[2]
'ì '

>>> creative[3]
'ì¸'

```

Indexing also works from the right, starting with aÂ `-1-based index`:

```
creative = 'ì°½ì˜ì ì¸'

>>> creative[-4]
'ì°½'

>>> creative[-2]
'ì '

>>> creative[-1]
'ì¸'

```

There is no separate "character" or "rune" type in Python, so indexing a string produces a newÂ `str`Â of length 1:

```

>>> website = "exercism"
>>> type(website[0])
<class 'str'>

>>> len(website[0])
1

>>> website[0] == website[0:1] == 'e'
True

```

Substrings can be selected viaÂ *slice notation*, usingÂ [`<str>[<start>:stop:<step>]`](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)Â to produce a new string. Results exclude theÂ `stop`Â index. If noÂ `start`Â is given, the starting index will be 0. If noÂ `stop`Â is given, theÂ `stop`Â index will be the end of the string.

```
moon_and_stars = 'ğŸŒŸğŸŒŸğŸŒ™ğŸŒŸğŸŒŸâ­'
sun_and_moon = 'ğŸŒğŸŒ™ğŸŒğŸŒ™ğŸŒğŸŒ™ğŸŒğŸŒ™ğŸŒ'

>>> moon_and_stars[1:4]
'ğŸŒŸğŸŒ™ğŸŒŸ'

>>> moon_and_stars[:3]
'ğŸŒŸğŸŒŸğŸŒ™'

>>> moon_and_stars[3:]
'ğŸŒŸğŸŒŸâ­'

>>> moon_and_stars[:-1]
'ğŸŒŸğŸŒŸğŸŒ™ğŸŒŸğŸŒŸ'

>>> moon_and_stars[:-3]
'ğŸŒŸğŸŒŸğŸŒ™'

>>> sun_and_moon[::2]
'ğŸŒğŸŒğŸŒğŸŒğŸŒ'

>>> sun_and_moon[:-2:2]
'ğŸŒğŸŒğŸŒğŸŒ'

>>> sun_and_moon[1:-1:2]
'ğŸŒ™ğŸŒ™ğŸŒ™ğŸŒ™'

```

Strings can also be broken into smaller strings viaÂ [`<str>.split(<separator>)`](https://docs.python.org/3/library/stdtypes.html#str.split), which will return aÂ `list`Â of substrings. The list can then be further indexed or split, if needed. UsingÂ `<str>.split()`Â without any arguments will split the string on whitespace.

```
>>> cat_ipsum = "Destroy house in 5 seconds mock the hooman."
>>> cat_ipsum.split()
...
['Destroy', 'house', 'in', '5', 'seconds', 'mock', 'the', 'hooman.']

>>> cat_ipsum.split()[-1]
'hooman.'

>>> cat_words = "feline, four-footed, ferocious, furry"
>>> cat_words.split(', ')
...
['feline', 'four-footed', 'ferocious', 'furry']

```

Separators forÂ `<str>.split()`Â can be more than one character. TheÂ whole stringÂ is used for split matching.

```

>>> colors = """red,
orange,
green,
purple,
yellow"""

>>> colors.split(',\n')
['red', 'orange', 'green', 'purple', 'yellow']

```

Strings support allÂ [common sequence operations](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations). Individual code points can be iterated through in a loop viaÂ `for item in <str>`. IndexesÂ *with*Â items can be iterated through in a loop viaÂ `for index, item in enumerate(<str>)`.

```

>>> exercise = 'á€œá€±á€·á€€á€»á€„á€ºá€·'

# Note that there are more code points than perceived glyphs or characters
>>> for code_point in exercise:
...    print(code_point)
...
á€œ
á€±
á€·
á€€
á€»
á€„
á€º
á€·

# Using enumerate will give both the value and index position of each element.
>>> for index, code_point in enumerate(exercise):
...    print(index, ": ", code_point)
...
0 :  á€œ
1 :  á€±
2 :  á€·
3 :  á€€
4 :  á€»
5 :  á€„
6 :  á€º
7 :  á€·

```

Instructions
------------

You are helping your younger sister with her English vocabulary homework, which she is finding very tedious. Her class is learning to create new words by addingÂ *prefixes*Â andÂ *suffixes*. Given a set of words, the teacher is looking for correctly transformed words with correct spelling by adding the prefix to the beginning or the suffix to the ending.

The assignment has four activities, each with a set of text or words to work with.

### 1\. Add a prefix to a word

One of the most common prefixes in English isÂ `un`, meaning "not". In this activity, your sister needs to make negative, or "not" words by addingÂ `un`Â to them.

Implement theÂ `add_prefix_un(<word>)`Â function that takesÂ `word`Â as a parameter and returns a newÂ `un`Â prefixed word:

```
>>> add_prefix_un("happy")
'unhappy'

>>> add_prefix_un("manageable")
'unmanageable'

```

### 2\. Add prefixes to word groups

There are four more common prefixes that your sister's class is studying:Â `en`Â (*meaning to 'put into' or 'cover with'*),Â `pre`Â (*meaning 'before' or 'forward'*),Â `auto`Â (*meaning 'self' or 'same'*), andÂ `inter`Â (*meaning 'between' or 'among'*).

In this exercise, the class is creating groups of vocabulary words using these prefixes, so they can be studied together. Each prefix comes in a list with common words it's used with. The students need to apply the prefix and produce a string that shows the prefix applied to all of the words.

Implement theÂ `make_word_groups(<vocab_words>)`Â function that takes aÂ `vocab_words`Â as a parameter in the following form:Â `[<prefix>, <word_1>, <word_2> .... <word_n>]`, and returns a string with the prefix applied to each word that looks like:Â `'<prefix> :: <prefix><word_1> :: <prefix><word_2> :: <prefix><word_n>'`.

```
>>> make_word_groups(['en', 'close', 'joy', 'lighten'])
'en :: enclose :: enjoy :: enlighten'

>>> make_word_groups(['pre', 'serve', 'dispose', 'position'])
'pre :: preserve :: predispose :: preposition'

>> make_word_groups(['auto', 'didactic', 'graph', 'mate'])
'auto :: autodidactic :: autograph :: automate'

>>> make_word_groups(['inter', 'twine', 'connected', 'dependent'])
'inter :: intertwine :: interconnected :: interdependent'

```

### 3\. Remove a suffix from a word

`ness`Â is a common suffix that meansÂ *'state of being'*. In this activity, your sister needs to find the original root word by removing theÂ `ness`Â suffix. But of course there are pesky spelling rules: If the root word originally ended in a consonant followed by a 'y', then the 'y' was changed to 'i'. Removing 'ness' needs to restore the 'y' in those root words. e.g.Â `happiness`Â -->Â `happi`Â -->Â `happy`.

Implement theÂ `remove_suffix_ness(<word>)`Â function that takes in aÂ `word`, and returns the root word without theÂ `ness`Â suffix.

```
>>> remove_suffix_ness("heaviness")
'heavy'

>>> remove_suffix_ness("sadness")
'sad'

```

### 4\. Extract and transform a word

Suffixes are often used to change the part of speech a word is assigned to. A common practice in English is "verbing" or "verbifying" -- where an adjectiveÂ *becomes*Â a verb by adding anÂ `en`Â suffix.

In this task, your sister is going to practice "verbing" words by extracting an adjective from a sentence and turning it into a verb. Fortunately, all the words that need to be transformed here are "regular" - they don't need spelling changes to add the suffix.

Implement theÂ `adjective_to_verb(<sentence>, <index>)`Â function that takes two parameters. AÂ `sentence`Â using the vocabulary word, and theÂ `index`Â of the word, once that sentence is split apart. The function should return the extracted adjective as a verb.

```
>>> adjective_to_verb('I need to make that bright.', -1 )
'brighten'

>>> adjective_to_verb('It got dark as the sun set.', 2)
'darken'
```
